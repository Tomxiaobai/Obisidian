## 动态规划 #递归  #记忆化
### 股票买卖系列
#### 简单的股票买卖
#### 股票买卖带手续费 #动规 #多维动态规划数组

- 给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。
  你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。
- 定义状态 $dp[i][0]$表示第 $i$天交易完后手里没有股票的最大利润，$dp[i][1]$表示第$i$天交易完后手里持有一支股票的最大利润（$i$从0开始）。
- 状态转移公式：
  
  $dp[i][0]$ = $\max$  $\{$$dp[i-1][0],dp[i-1][1]+prices[i]-fee$$\}$ [[Latex|Latex语法]]
  
  $dp[i][1]$ = $\max$  $\{$ $dp[i-1][1], dp[i-1][0]-prices[i]$$\}$
  
```java
class Soulution {
	public int maxProfit(int[] prices, int fee) {
		int n = prices.length;
		int[][] dp = new int[n][2]; 
		//其中dp[i][0] 表示不持有股票的到第i天的收益，dp[i][1]表示持有股票到第i天的收益
		dp[0][0] = 0;
		dp[0][1] = -prices[0];
		for (int i = 1; i < n; i++) {
			dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i] - fee);
			dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
		}
		return dp[n-1][0];
	}
}
```
- 详细的算法解析可以看[[每日清单#^lingcha|灵茶山艾府]]中的推荐链接
#### 股票买卖带手续费变种 #深交所 #动规 

- 给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。其中当股票持有时间大于k天时，手续费减半。
  你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值
- **warning** 因为需要记录持有了多少天，可以之间通过计算持有的天数来更新fee的大小
  $sell[i] = max$ $\{$$sell[i-1], sell[i]$$\}$
  上述式子主要表示当手上前一天不持有股票时和到目前不操作的最大值，其中$sell[i]$等价于0，因为到目前不操作始终为0
  
```java
class Solution {
	public int maxProfit(int[] prices, int fee, int k) {
		 int n = prices.length;
		 int[] buy = new int[n]; // 持有股票
		 int[] sell = new int[n]; //不持有股票
		 buy[0] = -prices[0];
		 sell[0] = 0;
		 for (int i = 1; i < n; i++) {
			 //第 i 天持有股票的最大利润为前一天持有股票的最大利润和前一天不持有股票的最大利润减去当天股票价格的较大值
			 buy[i] = Math.max(buy[i-1], sell[i-1] - prices[i]);
			 sell[i] = Math.max(sell[i-1], 0); // 今天不持有股票的最大利润为前一天不持有股票和不操作的较大值

			 // 更新持有k天的结果
			 for (int j = 1; j <= i; j++) {
				 int temp = fee;
				 if (j > k) {
					 temp /= 2;
				 }
				 sell[i] = Math.max(sell[i], buy[i-j] + prices[i] - temp);
			 } 
		 }
		 return sell[n-1]; // 返回最后一天不持有的最大值
	}
}
```
## 双指针
## 树状数组
## 背包算法
